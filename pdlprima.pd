# These are for THIS PD FILE (as opposed to the same code 10 lines
# below, which applied to the generated module file).
use strict;
use warnings;
use Carp 'croak';

pp_addpm({At=>'Top'},<<'ModuleMaterial');

BEGIN { 
$VERSION = '1.00'; 
} 

use strict;
use warnings;
use PDL;
use PDL::Char;
use Scalar::Util 'blessed';
use Carp 'croak';

# working here - use Exporter and set as 'EXPORT_OK' the functions
# pdl_of_patterns_for and pdl_of_handles_for. I need to write them, too.
# Their usage looks like this:
#  my $patters = pdl_of_patterns_for($pat1, $pat2, ...);
#  my $handles = pdl_of_handles_for($widget1, $widget2, ...);

=head1 NAME

PDL::Graphics::Prima - PDL-aware drawing functions for Prima widgets

=head1 SYNOPSIS

Each of the methods comes with a small sample snippet. To see how it
looks, copy this synopsis and replace the code with in the
C<Example code goes here> block with the example code.

 use strict;
 use warnings;
 use PDL;
 use PDL::Graphics::Prima;
 use Prima qw(Application);
 
 my $window = Prima::MainWindow->create(
     text    => 'PDL::Graphics::Prima Test',
     onPaint => sub {
         my ( $self, $canvas) = @_;
 
         # wipe the canvas:
         $canvas->clear;
         
         ### Example code goes here ###
         
         # Draw a sine curve on the widget:
         my ($width, $height) = $canvas->size;
         my $x = sequence($width);
         my $y = ( sin($x / 20) + 1 ) * $height/2;
         $canvas->pdl_polylines($x, $y, lineWidths => 2);
         
         ### Example code ends here ###
     },
     backColor => cl::White,
 );
 
 run Prima;

=head1 DESCRIPTION

working here - write this

=head2 Line patterns

It may happen that you want to draw a number of different lines, each with a
different line patter. There is a slight subtlety in how you do this.

Use byte arrays (or it will be cast to a byte array for you). All of the
patterns must have the same number of bytes in their specification, but there's
a decent chance that those specifications are different lenghts. In that case,
simply pad the shorter specifications with zeroes.

=head1 CONSIDERATIONS

The Prima image coordinate origin is located in lower left corner, which is
where you would expect to find it when creating plots. However, it is different
from the way that many graphics libraries do their coordinates.

=head1 METHODS

Each of the functions described below actually installs itself twice, under two
different names. For a given function <func>, the low-level implementation will
be available under PDL::_prima_<func>_int. They are discussed below, but
generally you should stick with the widget-oriented high-level
implementation. The high-level implementation is installed under
Prima::Drawable::pdl_<func> and is meant to be invoked as an object
method:

 $widget->pdl_polylines($x, $y);




# working here






If you decide you want to call the low-level functions, to reduce the
error-processing overhead, perhaps, you need to supply each and every
argument, in the proper order.

The
low-level functions require a huge number of arguments. I describe below
how to infer their argument calling semantics from the provided list of
required arguments and optional parameters, but I generaly discourage
their use.
The low-level functions are the raw functions generated by PDL::PP. Their error
checking is limited and they are not exported. If you want access to these
functions, you must invoke them with the full PDL package prefix, as:



=cut







# Builds a piddle of patterns with the appropriate sizes, etc.
sub piddle_of_patterns_for {
	# Make sure they're not being stupid:
	croak("You must supply at least one pattern to make a pattern piddle")
		if @_ == 0;

	# First get the longest pattern:
	my $length = 0;
	foreach(@_) {
		$length = length($_) if $length < length($_);
	}
	
	use PDL::NiceSlice;
	
	# Create the new byte array with the appropriate dimensions:
	my $to_return = zeroes(byte, $length, scalar(@_));
	$to_return .= $to_return->sequence;
	for (my $i = 0; $i < @_; $i++) {
		# Get a slice and update it:
		my $slice = $to_return(:,$i);
		substr ${$slice->get_dataref}, 0, length($_[$i]), $_[$i];
		
		# Make sure the modifications propogate back to the original:
		$slice->upd_data;
	}
	
	no PDL::NiceSlice;
	
	return $to_return;
}

sub piddle_of_handles_for {
	# Make sure they're not being stupid:
	croak("You must supply at least one widget from which to get a handle")
		if @_ == 0;
	
	# Make sure all of the variables are indeed widgets:
	foreach(@_) {
		croak("One or more of your widgets does not seem to be descended from Prima::Drawable")
			unless blessed($_) and $_->isa('Prima::Drawable');
	}
	
	# Make a piddle large enough to hold the handles:
	my $to_return = zeroes(long, scalar(@_));
	
	# put the handles in the piddle:
	_piddle_of_handles_for(${$to_return->get_dataref}, @_);
	
	# Update the piddle and return it:
	$to_return->upd_data;
	return $to_return;
}

ModuleMaterial

pp_addxs('', q{
void
_piddle_of_handles_for(SV * piddle_SV, ...)
	CODE:
		int i;
		/* Get at the piddle's actual data array */
		long * piddle = (long*)SvPVX(piddle_SV);
		/* Fill the array with the handle values */
		for (i = 1; i < items; i++) {
			piddle[i-1] = gimme_the_mate(ST(i));
		}

});
=for details
As far as I can tell, PDL::PP only defines the '_<func>_int' form of a function
when you specify a PMCode in the pp_def. I can't figure out where this happens
in PP.pm, but that appears to be the output behavior. For an introduction to
postscript, see http://local.wasp.uwa.edu.au/~pbourke/dataformats/postscript/
and http://www.physics.emory.edu/~weeks/graphics/howtops1.html

=cut

pp_addhdr( <<HEADER );

/* apricot is the (strangely named) header file that contains all of the
 * cross-platform functions.
 */

#undef WORD
#include <apricot.h>
#define MY_BIG_NUMBER 1000000

HEADER

#######################################################################
#                              Machinery                              #
#######################################################################

=begin details

=head1 Complex parameter handling

Each of the functions in this module wrap a PDL function around the
Prima API. The goal of the PDL functions is to allow the caller to
provide as many or as few tweaks to their drawing as they wish, so if
they want to draw three different polylines with three different line
styles, they should be able to do this:

 $widget->pdl_polylines($xs, $ys, {linePatterns => $patterns});

and it will DWIM. That means that the PP functions have to (1) get all
the possible preferences in as parameters (preferably piddles), (2) the
PP functions have to call the appropriate functions from apricot.h
to do their work, and (3) the PP functions have to package their piddles
in a form that the apricot.h functions know how to handle. To make
matters even more complicated, different API functions pay attention to
different properties, so different ones apply for different functions!

To deal with all of this, the next 400 or so lines of code create some
machinery that greatly assists in building the pp_defs that follow. A
great deal of this code is used in THIS script (.pd files are actually
scripts that generate .xs and .pm files) to assist in generating code.
Anything that needs to end up in the output files will be quoted.

=end details

=cut

###################################################
# Creating the look-up table for the Pars section #
###################################################

=begin details

This hash translates from a simple parameter name to a PDL signature.
Without this hash, if I wanted to write a function that allows the user
to draw lines with different colors, I would write the following Pars:

  Pars => 'int x(n); int y(n); int colors()'

So in the hash below, the property C<colors> is associated with the
arg string C<int colors()>, and (not-optional, but specially processed)
C<handles> property is associated with the arg string C<int handles()>.

=end details

=cut

my %pars_args_for = (colors => 'int colors()'
	, handles => 'int handles()'
);

=begin details

At the moment, I only have the colors property. If you know the Prima
Drawable API, you'll know I'm missing a lot! This is because I will
build up a number of structures over this discourse and I would
like to keep the code and specifications for each property in one place.
Scroll down to the 'Assembling machinery' portion of this code, about
175 lines below, and you'll see that all the parts for each of the
Drawable properties defined in one place.

=end details

=cut

#########################
# Generating Pars lists #
#########################

=begin details

This function creates a string with the low-level PDL function's argument
list, given a list of properties for the function. This makes it very
easy to manage long parameter lists, and long parameter lists are nicely
handled by the in-pm function C<get_sorted_args_with_defaults>. It also
adds handles to the signature, which is mandatory for each of these
functions. To expand on the previous example, in this code:

 pp_def(my_func,
        Pars => 'int x(n); int y(n); ' . generate_pars_args_for( 'colors', 'rops'),
        ...
 );

pp_def sees a parameter list that looks like this:

 'int x(n); int y(n); int handles(); int colors(); int rops()'

To use this, I will create a list of properties that the to-be-defined
function takes, and use that together with generate_pars_args_for like
so:

 my @clear_properties = qw(backColors rop2s);
 pp_def(prima_clear,
        Pars => 'int x1(); int y1(); int x2(); int y2(); '
                 . generate_pars_args_for(@clear_properites),
        PMCode => ...
 );

It may seem silly to use such an array for only two additional arguments
(as shown in this example), but other parts of the pp_def call will make
use of that array, as we will see, and most of the functions use many
more properties.

=end details

=cut

sub generate_pars_args_for {
	foreach (@_) {
		croak("Bad args; should be plural") unless /s$/;
	}
	return join('; ', @pars_args_for{'handles', @_});
}

######################################
# Property-dependent local variables #
######################################

=begin details

As already mentioned, many of the properties that could potentially be
sent to the drawing apricot.h functions will need a set of local
variables. Currently, clipRects and linePatterns need special variables
to do their work, and these variables should be created outside the
threadloop. (regions, when implemented, may need to use this, too.)
Functions that do not care about those properties will not need those
variables, so they should only be included in functions that actually
use them. generate_init_args_for handles this code generation, taking
the same array of properties used by generate_pars_args_for. See the
next section for an example of use.

Note that entries in C<%init_args_for> should be semi-colon seperated,
since they are C declarations, but the last entry should not have a 
semi-colon. One will be appended. This is to keep consistency with
C<%pars_args_for>, which has the same format.

=end details

=cut

my %init_args_for = ();

sub generate_init_args_for {
	my $to_return = "\t\t/* These are declarations needed for the handles
		 * and some of the optional parameters */
		 Handle widget_handle;\n";
		 
	# Build the list:
	foreach(@_) {
		$to_return .= "\t\t$init_args_for{$_};\n"
			if exists $init_args_for{$_};
	}
	
	return $to_return;
}

##########################################
# Tracking which properties need setting #
##########################################

=begin details

The only way to determine from within PP code whether an optional
parameter was passed in or not is to pass an additional structure to
the PP code with that information. The structure I use for this is
the original hash passed in as
an argument to the Perl-level function. If the user specified a value
for a property, it will be present in the hash. If they did not, it will
not be there.

So, for each of the graphics properties that the user can supply for a
given function, I will want to have code in the PP Code section that
looks something like this:

 SV* arg_hash_HV = SvRV(arg_rev_sv);
 int is_setting_rops;
 is_setting_rop = hv_exists_ent(arg_hash_hv, sv_2mortal(newSVpv("rops", 0)), 0);

This code checks if the key "rops" exists in the arg_hash_hv hash (which
must be passed in to the PP function via OtherPars). The
return value is a boolean, which I will use in the threadloop. Looking
up these values once and storing their results will make the resulting
code much less cluttered, and hopefully faster.

Here's a function that generates the code for me, based on the supplied
list of properties. It's a little different from the example above, but
they basically do the same thing. It, too, uses the same array of
properties used by generate_pars_args_for. The auto-generated code from
this function is inserted directly into the Code key in the pp_def
function call, like so:

 my @func_pars = qw(backColor linePattern);
 pp_def('my_func',
     Pars => 'int arg1(n); ' . generate_pars_args_for(@func_pars),
     ...
     Code => q{
         /* set-up variables I will need throughout the threadloop */
         int alpha;
     } . generate_init_args_for(@func_pars)
       . create_boolean_setters_for(@func_pars)
     . q{
         alpha = -1;
         ... 
         threadloop %{
             ...
         %}
     },

=end details

=cut

sub create_boolean_setters_for {
	# Make sure I handle an empty list correctly. I can't imagine
	# calling this function with an empty list, but let's be safe:
	return '' unless @_;
	# This is the string I will build up for my return value:
	my $to_return = "
		/* The last of the declarations */
		SV* key;
		HV* arg_hash_hv;
		int ";
	# Create the variable list (is_setting_colors, is_setting_lineWidths...):
	$to_return .= join(', ', map {"is_setting_$_"} @_) . ";\n";
	
	# Set the variables:
	$to_return .= "
		/* Begin initializing the values */
		key = sv_newmortal();
		arg_hash_hv = (HV*)SvRV(\$COMP(arg_ref_sv));
";
	foreach(@_) {
		$to_return .= "\t\tsv_setpv(key, \"$_\");\n"
					. "\t\tis_setting_$_ = hv_exists_ent(arg_hash_hv, key, 0);\n";
	}
	return $to_return;
}

####################################
# Creating the initialization code #
####################################

=begin details

I've built up a lot of machinery to handle the various required arguments
and optional properties. This next chunk of code gives a single function
that will call everything in the proper order to declare and initialize
the necessary variables, early within the Code section.

=end details

=cut

sub initialize_for {
	my @properties = @_;
	return '
		/* BEGIN AUTOGENERATED INITIALIZATION */

	' . generate_init_args_for(@properties)
	  . create_boolean_setters_for(@properties) . '
		
		/* END AUTOGENERATED INITIZLIATION */
	';
}

my $default_other_pars = 'SV * arg_ref_sv';

#################################
# Calling the apricot.h setters #
#################################

=begin details

Each of the setters needs to first check if its call is even necessary
(using the boolean variables set-up in the previous section),
and then it needs to call the appropriate setter from apricot.h. This is
easy but repetitive code, so once again I generate it from the same
list of arguments as everything else. In what follows, I create a
function that generates these code fragments for me, or looks them up
in a hash if they're complicated. Note that the function wraps the
looked-up code in its own curly-braced block; all you need to write is
the code itself like the following colors example shows:

The auto-generated code for this section is inserted directly into the
Code key in the pp_def function call, within the threadloop, before the
apricot function for this function is itself called. For example:

 q[
     ...
     threadloop %{
		 /* Apply any per-threadloop tweaks */
         ] . generate_setter_code_for(@func_pars)
         . q[
         /* Call the apricot function */
         apc_gp_set_func(args);
     %}
 ]

=end details

=cut

my %set_code_for = (
	colors => q{
				/* cast the integer as a Colors type (which itself is a
				 * 32-bit int, so maybe this is unnecessary */
				apc_gp_set_color(widget_handle, (Color)$colors());
},
);

sub generate_single_setter_code_for {
	my $property = shift;
	# Make the singular name from the plural:
	(my $singular = $property) =~ s/s$//;
	# apricot uses underscores and all lowercase instead of CamelCase:
	(my $apricot  = $singular) =~ s/([A-Z])/_\l$1/g;
	# Build the return string:
	my $to_return = "\t\t\tif (is_setting_$property) {\n";
	if (exists $set_code_for{$property}) {
		# Insert special handling code:
		$to_return .= $set_code_for{$property};
	}
	else {
		# Most other properties are direct sets:
		$to_return .= "\t\t\t\tapc_gp_set_$apricot(widget_handle, \$$property());\n";
	}
	
	$to_return .= "\t\t\t}";
}

sub generate_setter_code_for {
	return "
			widget_handle = (Handle)\$handles();
			/* BEGIN AUTOGENERATED SETTER CHECKS */\n"
			. join("\n", (map {generate_single_setter_code_for($_)} @_)) . "
			/* END AUTOGENERATED SETTER CHECKS */\n";
}

##################################################
# Building machinery for the different properies #
##################################################

=begin details

Now that I have all of the infrastructure ready, I need to build up the
data structures for each of the properties.

=end details

=cut

# Background color:
$pars_args_for{backColors} = 'int backColors()';
$set_code_for{backColors} = q{
				/* cast the integer as a Colors type (actually an int) */
				apc_gp_set_back_color(widget_handle, (Color)$backColors());
};

# Clipping rectangle:
$pars_args_for{clipRects} = 'int clipLeft(); int clipBottom(); int clipRight(); int clipTop()';
$init_args_for{clipRects} = 'Rect clip_rect';
$set_code_for{clipRects} = q{
				clip_rect.left = $clipLeft();
				clip_rect.bottom = $clipBottom();
				clip_rect.right = $clipRight();
				clip_rect.top = $clipTop();
				apc_gp_set_clip_rect(widget_handle, clip_rect);
};

# These do no need any special args, and the default generated code will
# work just fine:
$pars_args_for{lineEnds} = 'int lineEnds()';
$pars_args_for{lineJoins} = 'int lineJoins()';
$pars_args_for{lineWidths} = 'int lineWidths()';
$pars_args_for{rops} = 'int rops()';
$pars_args_for{rop2s} = 'int rop2s()';

# line patterns. This code has to cast the byte piddle into a char and
# send that and the length to the line_pattern function.
$pars_args_for{linePatterns} = 'byte linePatterns(patlen)';
$init_args_for{linePatterns} = 'unsigned char * pattern; int pattern_length';
$set_code_for{linePatterns} = q{
				pattern = (unsigned char *)$P(linePatterns);
				pattern_length = strlen(pattern);
				apc_gp_set_line_pattern(widget_handle, pattern, pattern_length);
};

# translation; the apricot function for translate uses a different name
# and takes two arguments instead of one:
$pars_args_for{translates} = 'int trans_x(); int trans_y()';
$set_code_for{translates} = q{
				/* invoke the apricot function with both x and y */
				apc_gp_set_transform(widget_handle, $trans_x(), $trans_y());
};

# Fill winding works nicely without any alteration:
$pars_args_for{fillWindings} = 'int fillWindings()';

# Fill pattern will may work nicely without any alteration, but I am
# going to be explicit and cast the fillPattern piddle into a U8 array:
$pars_args_for{fillPatterns} = 'byte fillPatterns(oct=8)';
$set_code_for{fillPatterns} = q{
			/* Casts the pattern as a U8 pointer and continues */
			apc_gp_set_fill_pattern(widget_handle, (U8*)$P(fillPatterns));
};

# Spline precision works well with the default setup:
$pars_args_for{splinePrecisions} = 'int splinePrecisions()';

# Ignoring for now: region
# The underlying graphics functions explicitly operate with a 1-bit-per-pixel
# Prima::Image bitmap. I could use PDL::PrimaImage as the argument, but
# that seems like a lot of repackaging for every round in the PP
# threadloop. Alternatively, I could take an array ref with Prima::Image
# objects as the argument, and simply cycle through that.


#######################################################
# Argument processing, ordering, and default handling #
#######################################################

=begin details

Each of the perl-side functions that gets invoked as an object
method checks its arguments. It does this by analyzing the hash sent in
by the caller, checking for properties that don't belong, or were
mis-spelled, and repackaging the results into a list with the exact
order needed by the PP code. Most parameters take a single piddle as
their argument, but some don't. This code needs to know how many
arguments go with each parameter, so it can check that, too. Such a list
of parameters can be automatically constructed from the already-defined
%pars_args_for hash.

=end details

=cut

pp_addpm (join("\n"
	, '# This is a list of the number of arguments for each property. It is based on the'
	, '# pars_args_for hash which is built in the .pd file associated with this module'
	, 'my %N_args_for = qw('
	# Note that the tr operator, as used, just counts the number of semi-colons
	# in the pars args associated with the property.
	, (map {sprintf "\t%-20s %d", $_, ($pars_args_for{$_} =~ tr/;//) + 1}
		(keys %pars_args_for))
	, ');'
	)
);

=begin details

Having collected the number of arguments associated with each of the
properties, I need a function to actually process the hash.
This is a function that I call in all of my PMCode sections. It takes an
anonymous list of names and an anonymous hash. If the hash has a key for
one of the names, it includes that in the return list. If it doesn't, it
returns the default value of a 0-dim piddle with value 0. If one of the
hash keys is not in the list of names, it croaks.

Put a little differently, this function takes an anonymous hash, makes
sure there are no extraneous arguments, extracts the desired arguments
or uses a sensible default, and returns the arguments in the desired
order.

=end details

=cut

pp_addpm <<'DefaultArgumentHandling';

sub get_sorted_args_with_defaults {
	my ($self, $arg_names, $given) = @_;
	
	# Default to an empty list:
	$given = {} unless ref($given) eq 'HASH';
	
	# Copy the arg_names array, so I can add 'handles' to it without
	# effecting the original array:
	my @arg_names = @$arg_names;
	unshift @arg_names, 'handles';
	
	# Check that they supplied only allowed parameters:
	foreach (keys %$given) {
		croak("Unknown parameter $_") unless $_ ~~ @$arg_names
	}
	
	# Create a 0-dim piddle with this object's hande in it:
	my $handle = piddle_of_handles_for($self);
	
	# Return the sorted list of supplied or default values
	my @to_return = ();
	foreach ('handles', @$arg_names) {
		# If not specified, return a default property of a zero-dim
		# piddle. Except for the handles, the value doesn't matter
		# because it is never used. For handles, the value should revert
		# to the calling widget's handle:
		if (not exists $given->{$_}) {
			push @to_return, ($handle) for (1..$N_args_for{$_});
		}
		elsif (ref ($given->{$_}) eq 'ARRAY') {
			# If an array ref, dereference it and make sure the number
			# of arguments agrees with what we expect:
			if (@{$given->{$_}} != $N_args_for{$_}) {
				croak("Expected 1 argument for $_") if $N_args_for{$_} == 1;
				croak("Expected $N_args_for{$_} arguments for $_");
			}
			push @to_return, @{$given->{$_}};
		}
		else {
			# Otherwise, return it outright, if we only expected one
			# argument:
			$N_args_for{$_} == 1
				or croak("Expected $N_args_for{$_} arguments for $_");
			
			push @to_return, $given->{$_};
		}
	}
	return @to_return;
}

DefaultArgumentHandling


###################################
# Generating PMCode automatically #
###################################

=begin details

The PMCode section of each of these is pretty much the same. This
snippet of code generates that code for me. It takes the names of the
arguments and returns the autogenerate PMCode.

This code is very dense. I hope that it is documented well enough with
comments that any future maintainer will be able to understand it. If
in doubt, this function operates stand-alone, so you can copy it into
a little test script and try calling it with sample parameters to get a
feel for how it behaves.

working here - I have a few argument checking
ideas for this function, including
considering checking that C<$self> is a Prima::Drawable type, but not
Prima::PS::Drawable. Also, I bet if PDL barfs, it'll point to the line
in the (generated) pm file, so the pdl function call should probably be
wrapped in an eval block, and $@ should be post-processed.

=end details

=cut

sub generate_PMCode_for {
	my ($func_name, $props, @arg_names) = @_;
	my $props_array_name = '@' . $func_name . '_props';
	my $args_array_name = '@' . $func_name . '_args';
	# Outside the function definition, create the list of properties
	# that this function uses, as well as the names of the arguments.
	# It needs these lists in the actual Perl module file so it can
	# check the passed arguments and provide meaningful error messages:
	my $to_return = "my $props_array_name = qw(@$props);\n"
				. "my $args_array_name = qw(@arg_names);\n";
	
	# Define the drawable function in the Prima::Drawable namespace
	# and check for arguments:
	$to_return .= "sub Prima::Drawable::pdl_$func_name {
	# Before anything else, make sure they supplied at least the
	# required number of arguments:
	croak('pdl_$func_name expectes '. scalar($args_array_name)
		. ' arguments (and the widget): ' . join(', ', 'widget', $args_array_name))
		unless (\@_ > $args_array_name);

	# unpack the widget and the required arguments for this function:
";
	foreach ('self', @arg_names) {
			$to_return .= "\tmy \$$_ = shift;\n";
	}
	$to_return .= "
	# Check for an even number of remaining arguments (key-value pairs):
	croak('pdl_$func_name expects optional parameters ans key => value pairs')
		unless \@_ % 2 == 0;
	
	my \%args = \@_;
	
	# Get the a full list of arguments suitable for the internal pp code
	# in the correct order:
	my \@args_with_defs
		= get_sorted_args_with_defaults(\$self, \\$props_array_name, \\\%args);

	# Call the PP'd internal code. Always put the args hash last.
	eval {
		PDL::_prima_${func_name}_int(";
	# include all the required arguments:
	foreach(@arg_names) {
		$to_return .= '$' . $_ . ', ';
	}
	# finish with self and the args list:
	$to_return .= '@args_with_defs, \%args);
	};
	
	if ($@) {
		# die $@;
		$@ =~ s/at (.*?) line \d+\.\n$//;
		croak "Issues calling pdl_' . $func_name . ': $@";
	}
	' . "\n}\n";
	 
	return $to_return;
}


#######################################################################
#                              Functions                              #
#######################################################################

=begin details

At last I begin the declaration of PP code. The idea behind all of this
machinary is that I declare a collection of applicable properties in
THIS SCRIPT, and then use that to generate consistent code blocks. I
even use the properties array to generate compile-time accurate
documentation, so the on-machine documentation can never go out-of-sync
with the on-machine library.

=end details

=cut

##############
# prima_arcs #
##############

my @properties = qw(colors backColors lineEnds linePatterns lineWidths rops rop2s translates);
pp_def('prima_arcs',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('arcs', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for arcs, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_arc(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_arcs

=for sig

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                     start_angle(); end_angle(); properties)

=for ref

Draws arcs, i.e. incomplete ellipses.

The arcs go from the C<start_angle>s to the C<end_angle>s along the
ellipses centered at the C<x>s and C<y>s, with the specified x- and
y-diameters. The angles are measured in degrees, not radians.
The difference between this command and L</chords> or L</sectors> is that
C<arcs> does not connect the dangling ends.

Here's a simple example:

=for example

 # Draw a bunch of random arcs on $canvas:
 my $N_arcs = 20;
 my ($x_max, $y_max) = $canvas->size;
 my $xs = zeroes($N_arcs)->random * $x_max;
 my $ys = $xs->random * $y_max;
 my $dxs = $xs->random * $x_max / 4;
 my $dys = $xs->random * $y_max / 4;
 my $th_starts = $xs->random * 360;
 my $th_stops = $xs->random * 360;
 
 # Now that we've generated the data, call the command:
 $canvas->pdl_arcs($xs, $ys, $dxs
                , $dys, $th_starts, $th_stops);

If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of arcs will get
redrawn whenever you resize your window.


Compare to the Prima method L<Prima::Drawable/arc>. Closely related
routines include L</pdl_chords> and L</pdl_sectors>. See also
L</pdl_fill_chords>, and L</pdl_fill_sectors>, L</pdl_ellipses>, and
L</pdl_fill_ellipses>.

Spline drawing provides a similar functionality, though more complex and
more powerful. There are no PDL bindings for the spline functions yet.
See L<Prima::Drawable/spline> for more information.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

"

);

=pod

Applicable properties are likely to include handles, colors, backColors,
lineEnds, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

##############
# prima_bars #
##############

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_bars',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('bars', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's bar function */
			apc_gp_bar(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_bars

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws filled rectangle from corner (x1, y1) to (x2, y2).

=for example

 # Draw 20 random filled rectangles on $canvas:
 my $N_bars = 20;
 my ($x_max, $y_max) = $canvas->size;
 my $x1s = zeroes($N_bars)->random * $x_max;
 my $y1s = $x1s->random * $y_max;
 my $x2s = $x1s + $x1s->random * ($x_max - $x1s);
 my $y2s = $y1s + $x1s->random * ($y_max - $y1s);
 my $colors = $x1s->random * 2**24;
 
 # Now that we've generated the data, call the command:
 $canvas->pdl_bars($x1s, $y1s, $x2s, $y2s
         , colors => $colors, backColors => $colors);

If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of filled rectangles
will get redrawn whenever you resize your window.

Compare to the Prima method L<Prima::Drawable/bar>. See also
L</pdl_rectangles>, which is the unfilled equivalent, and L</pdl_clears>,
which is sorta the opposite of this.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut


################
# prima_chords #
################
@properties = qw(colors backColors clipRects lineEnds linePatterns lineWidths rops rop2s translates);
pp_def('prima_chords',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('chords', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for chords, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's chord function */
			apc_gp_chord(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_chords

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                           start_angle(); end_angle(); properties)

=for ref

Draws arcs (i.e. incomplete ellipses) whose ends are connected by a line.

The chord starts at C<start_angle> and runs to C<end_angle> along the ellipse
centered at C<x>, C<y>, with their specified diameters C<x_diameter>,
C<y_diameter>. Unlike L</arcs> or L</sectors>, it connects
the ends of the arc with a straight line. The angles are
measured in degrees, not radians.

=for example

 # For this example, you will need:
 use PDL::Char;
 
 # Draw a bunch of random arcs on $canvas:
 my $N_chords = 20;
 my ($x_max, $y_max) = $canvas->size;
 my $xs = zeroes($N_chords)->random * $x_max;
 my $ys = $xs->random * $y_max;
 my $dxs = $xs->random * $x_max / 4;
 my $dys = $xs->random * $y_max / 4;
 my $th_starts = $xs->random * 360;
 my $th_stops = $xs->random * 360;
 
 # make a small list of patterns:
 my $patterns_list = PDL::Char->new(
          [lp::Solid, lp::Dash, lp::DashDot]);
 
 # Randomly select 20 of those patterns:
 my $rand_selections = ($xs->random * 3)->byte;
 use PDL::NiceSlice;
 my $patterns = $patterns_list($rand_selections)->transpose;
 
 # Now that we've generated the data, call the command:
 $canvas->pdl_chords($xs, $ys, $dxs
                , $dys, $th_starts, $th_stops
                , linePatterns => $patterns);

If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of chords
will get redrawn whenever you resize your window.

Compare to the Prima method L<Prima::Drawable/chord>. The filled
equivalent is L</pdl_fill_chords>. Closely related routines are
L</pdl_arcs> and L</pdl_sectors>. See also L</pdl_fill_sectors>,
L</pdl_ellipses>, and L</pdl_fill_ellipses>, as well as
L<Prima::Drawable/spline>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

################
# prima_clears #
################

@properties = qw(backColors rop2s translates);
pp_def('prima_clears',
	Pars => 'int x1(); int y1(); int x2(); int y2();'
			. generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('clears', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for clears, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's clear function */
			apc_gp_clear(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_clears

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Clears the specified rectangle(s).

=for example

 my ($width, $height) = $canvas->size;
 # Begin by drawing a filled rectangle:
 $canvas->color(cl::Blue);
 $canvas->bar(0, 0, $width, $height);
 
 # Now cut random rectangles out of it:
 my $N_chunks = 20;
 my $x1 = random($N_chunks) * $width;
 my $x2 = random($N_chunks) * $width;
 my $y1 = random($N_chunks) * $width;
 my $y2 = random($N_chunks) * $width;
 $canvas->pdl_clears($x1, $y1, $x2, $y2);

Like the other examples, this will give you something new whenever you
resize the window if you put the code in the onPaint method, as the
Synopsis suggests.

Compare to the Prima method L<Prima::Drawable/clear>. In practice I
suppose this might be considered the opposite of L</pdl_bars>, though
technically this is meant for erasing, not drawing.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, backColors, rop2s,
and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

####################
# prima_draw_texts #
####################

# Not implemented

##################
# prima_ellipses #
##################

@properties = qw(colors backColors clipRects linePatterns lineWidths rops rop2s translates);
pp_def('prima_ellipses',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();'
			. generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('ellipses', \@properties, qw(x y x_diameter y_diameter)),
	Code => 
	# I don't need any extra variables for ellipses, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's ellipse function */
			apc_gp_ellipse(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter());
		%}
	],
	Doc => q{

=head2 pdl_ellipses

  Prima Signature: (widget; x(); y(); x_diameter();
                          y_diameter(); properties)

=for ref

Draws an ellipse centered at C<x>, C<y> with diameters C<x_diameter> and
C<y_diameter>. To draw circles, just use the same x- and y-diameter.

=for example

 working here

Compare to the Prima method L<Prima::Drawable/ellipse>. The filled
equivalent is L</pdl_fill_ellipses>. See also L</pdl_arcs>, L</pdl_chords>,
and L</pdl_sectors> as well as L</pdl_fill_chords> and
L</pdl_fill_sectors>. You may also be interested in L<Prima::Drawable/spline>,
which does not yet have a PDL interface.

=cut



}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#####################
# prima_fill_chords #
#####################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_fill_chords',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('fill_chords', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for chords, filled or otherwise,
	# so I'll just add the auto-generated declaration and initialization
	# code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's fill_chord function */
			apc_gp_fill_chord(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_fill_chords

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                          start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters. The ends
are connected with a line and the interior is filled. Use this to draw
the open-mouth part of a smiley face.

=for example

 # working here:
 $canvas->pdl_fill_chords($x, $y, $xd, $yd, $ti, $tf);

Compare to the Prima method L<Prima::Drawable/fill_chord>. The unfilled
equivalent is L</pdl_chords>. Closely related to L</pdl_fill_ellipses>
and L</pdl_fill_sectors>. See also L</pdl_arcs>, L</pdl_ellipses>,
and L</pdl_sectors>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#######################
# prima_fill_ellipses #
#######################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_fill_ellipses',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('fill_ellipses', \@properties, qw(x y x_diameter y_diameter)),
	Code => 
	# I don't need any extra variables for ellipses, filled or otherwise,
	# so I'll just add the auto-generated declaration and initialization
	# code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's fill_ellipse function */
			apc_gp_fill_ellipse(widget_handle, $x(), $y(), $x_diameter(), $y_diameter());
		%}
	],
	Doc => q{

=head2 pdl_fill_ellipses

  Prima Signature: (widget; x(); y(); x_diameter();
                          y_diameter(); properties)

=for ref

Draws a filled ellipse centered at C<x>, C<y>, with diameters
C<x_diameter> and C<y_diameter>. To draw filled circles, use the same
value for both diameters.

=for example

 # working here
 $canvas->pdl_fill_ellipses($x, $y, $xd, $yd);

Compare to the Prima method L<Prima::Drawable/fill_ellipse>. The unfilled
equivalent is L</pdl_ellipses>. Closely related to L</pdl_fill_chords> and
L</pdl_fill_ellipses>, and L</pdl_fill_sectors>.
See also L</pdl_arcs>, L</pdl_ellipses>, and L</pdl_sectors>. Also,
check out L<Prima::Drawable/fill_spline>, which does not yet have
PDL bindings.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

####################
# prima_fillpolys #
####################
@properties = qw(colors backColors clipRects fillPatterns fillWindings rops rop2s translates);
pp_def('prima_fillpolys',
	Pars => 'x(n); y(n); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('fillpolys', \@properties, qw(x y)),
	Code => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs gracefully, and I am simply skipping over
			 * nan values, treating them just as I would bad values.
			 * Note that polylines draws a gap at bad values, but here
			 * I simply skip over them.
			 */
			n_to_plot = 0;
			for(i = 0; i < n_size; i++) {
				xval = $x(n => i);
				yval = $y(n => i);

				/* Move to the next value if we encounter nan */
				if (xval != xval || yval != yval) {		/* nan check */
					continue;
				}

				/* handle infinities */
				if (xval == xval + 1) {
					if (xval < 0)
						xval = -MY_BIG_NUMBER;
					else
						xval = MY_BIG_NUMBER;
				}
				if (yval == yval + 1) {
					if (yval < 0)
						yval = -MY_BIG_NUMBER;
					else
						yval = MY_BIG_NUMBER;
				}
				/* Handle very large values */
				if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
				if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
				if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
				if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
				
				to_plot[n_to_plot].x = xval;
				to_plot[n_to_plot].y = yval;

				/* Keep track of the number of points added */
				n_to_plot++;
			}
			/* Call apricot's fillpoly function */
			if (n_to_plot > 2)
				apc_gp_fill_poly(widget_handle, n_to_plot, to_plot);
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	HandleBad => 1,
	BadCode => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs gracefully, and I am simply skipping over
			 * nan values and BAD values.
			 * Note that polylines draws a gap at bad values, but here
			 * I simply skip over them.
			 */
			n_to_plot = 0;
			for(i = 0; i < n_size; i++) {
				xval = $x(n => i);
				yval = $y(n => i);

				/* Move to the next value if we encounter something bad */
				if (xval != xval || yval != yval	/* nan check */
					|| $ISBAD(x(n => i))			/* bad value */
					|| $ISBAD(y(n => i))) {			/* checks    */
					continue;
				}

				/* handle infinities */
				if (xval == xval + 1) {
					if (xval < 0)
						xval = -MY_BIG_NUMBER;
					else
						xval = MY_BIG_NUMBER;
				}
				if (yval == yval + 1) {
					if (yval < 0)
						yval = -MY_BIG_NUMBER;
					else
						yval = MY_BIG_NUMBER;
				}
				/* Handle very large values */
				if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
				if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
				if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
				if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
				
				to_plot[n_to_plot].x = xval;
				to_plot[n_to_plot].y = yval;

				/* Keep track of the number of points added */
				n_to_plot++;
			}
			/* Call apricot's fillpoly function */
			if (n_to_plot > 2)
				apc_gp_fill_poly(widget_handle, n_to_plot, to_plot);
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	Doc => q{

=head2 pdl_fillpolys

  Prima Signature: (widget; x(n); y(n); properties)

=for ref

Draws and fills a polygon with arbitrary edge vertices.

NOTE: there is B<no> underscore between C<fill> and C<poly>, which is
different from the other C<fill> methods!

This is most useful for drawing line drawing of crystals and rocks, and
for visualizing integrals. Splines would be the better choice if you
want to draw curves, but a PDL interface to splines is not (yet)
implemented.

Unlike most of the other methods, this one actually makes an effort to
process bad values. In addition to the IEEE bad values of C<nan> and
C<inf>, PDL has support for bad values. All of these should be handled
reasonably well by C<pdl_fillpolys>. If you give it 

Because this skips bad data altogether, if you have too much bad data
(i.e. fewer than three good points), the routine will simply not draw
anything. I'm debating if this should croak, or at least give a warning.
(Of course, a warning to STDOUT is rather silly for a GUI toolkit.)

For example:

=for example

 # working here
 $canvas->pdl_fillpolys($x, $y);

Compare to the Prima method L<Prima::Drawable/fillpoly>. See also
L</pdl_bars> and L<pdl_polylines>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns, fillWindings,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

######################
# prima_fill_sectors #
######################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_fill_sectors',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('fill_sectors', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for filled sectors, so I'll just
	# add the auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_fill_sector(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_fill_sectors

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                          start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, with specified x- and y-diameters. Like
L</fill_chords>, this command connects the end points of the arc, but
unlike L</fill_chords>, it does so by drawing two lines, both of which
also connect to the ellipse's center. This results in shapes that look
like pie pieces.

=for example

 # working here
 $canvas->pdl_fill_sectors($x, $y, $xd, $yd, $th1, $th2);

Compare to the Prima method L<Prima::Drawable/fill_sector>. The unfilled
equivalent is L</pdl_sectors>. This is closely related to C</pdl_fill_chords>
and C</pdl_fill_ellipses>. See also L</pdl_arcs>, L</pdl_chords>, and
L</pdl_ellipses>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

######################
# prima_fill_splines #
######################

# Not implemented

#####################
# prima_flood_fills #
#####################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_flood_fills',
	Pars => 'int x(); int y(); int color(); int singleborder(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('flood_fills', \@properties, qw(x y color singleborder)),
	Code => 
	# I don't need any extra variables for flood fills, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's lines function */
			apc_gp_flood_fill(widget_handle, $x(), $y(), (Color)$color(), $singleborder());
		%}
	],
	Doc => q{

=head2 pdl_flood_fills

  Prima Signature: (widget; x(); y(); color();
                   singleborder(); properties)

=for ref

# working here:

Fills an area of the canvas...

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

###############
# prima_lines #
###############

@properties = qw(colors backColors clipRects linePatterns lineWidths rops rop2s translates);
pp_def('prima_lines',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('lines', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's lines function */
			apc_gp_line(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_lines

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws a line from (x1, y1) to (x2, y2).

In contrast to polylines, which are supposed to be connected, these
lines are meant to be independent.

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

################
# prima_pixels #
################

@properties = qw(colors clipRects translates);
pp_def('prima_pixels',
	Pars => 'int x(); int y(); int [o] color(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('pixels', \@properties, qw(x y color)),
	Code => 
	# I don't need any extra variables for pixels, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q{
		threadloop %{
			/* Unlike usual, I will not use the setter code. Rather,
			 * the is_setting_colors will determine whether or not I
			 * set the pixel:
			 */
			if (is_setting_colors) {
				apc_gp_set_pixel(widget_handle, $x(), $y(), (Color)$colors());
			}
			
			/* No matter what, get the previous color. NOTE that the
			 * retrieved results goes in color (singular), not colors
			 */
			$color() = (PDL_Long) apc_gp_get_pixel(widget_handle, $x(), $y());
		%}
	},
	Doc => q{

=head2 pdl_pixels

  Prima Signature: (widget; x(); y(); properties)

=for ref

Sets the pixel at (x, y) to the current color, or to the value(s) passed
in the C<color> property.

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, clipRects, and
translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

###################
# prima_polylines #
###################

@properties = qw(colors backColors clipRects lineEnds lineJoins linePatterns
					lineWidths rops rop2s translates);
pp_def('prima_polylines',
	Pars => 'x(n); y(n); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('polylines', \@properties, qw(x y)),
	Code => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
		/* Need these to do reasonable cutting-out of data outside the
		 * plotting window
		 */
		int x_min, x_max, y_min, y_max;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Get the min/max data */
			if (is_setting_clipRects) {
				/* If they specified a clipping rectangle, just use
				 * those bounds */
				x_min = $clipLeft();
				y_min = $clipBottom();
				x_max = $clipRight();
				y_max = $clipTop();
			}
			else {
				/* Otherwise, get the clip rectangle for the widget
				 * and use its bounds */
				 clip_rect = apc_gp_get_clip_rect(widget_handle);
				 x_min = clip_rect.left;
				 y_min = clip_rect.bottom;
				 x_max = clip_rect.right;
				 y_max = clip_rect.top;
			}
			
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs and nans gracefully by treating the same
			 * way as I would bad values.
			 */
			for(i = 0; i < n_size; /* no action */) {
				for(n_to_plot = 0; n_to_plot + i < n_size; n_to_plot++) {
					int total_offset = n_to_plot + i;
					xval = $x(n => total_offset);
					yval = $y(n => total_offset);
					
					/* Finish this segment if we encounte nan */
					if (xval != xval || yval != yval) {		/* nan check */
						/* increment i so that it skips this value on
						 * the next round
						 */
						i++;
						break;
					}
					
					/* handle infinities */
					if (xval == xval + 1) {
						if (xval < 0)
							xval = -MY_BIG_NUMBER;
						else
							xval = MY_BIG_NUMBER;
					}
					if (yval == yval + 1) {
						if (yval < 0)
							yval = -MY_BIG_NUMBER;
						else
							yval = MY_BIG_NUMBER;
					}
					
					/* Handle very large values */
					if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
					if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
					if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
					if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
					
					to_plot[n_to_plot].x = xval;
					to_plot[n_to_plot].y = yval;

					/* Handle values that are outside the plotting range
					 * by comparing them to the previous point. This
					 * clearly requires that there was a previous point:
					 */
					if (n_to_plot > 0							/* a previous point exists	*/
						 && ( xval < x_min || xval > x_max		/* and current point is		*/
							|| yval < y_min || yval > y_max)	/* outside range			*/
						 && ( to_plot[n_to_plot-1].x < x_min	/* and previous				*/
							|| to_plot[n_to_plot-1].x > x_max	/* point					*/
							|| to_plot[n_to_plot-1].y < y_min	/* is outside				*/
							|| to_plot[n_to_plot-1].y > y_max)	/* range					*/
					) {
						/* If any point on a line from the previous to
						 * this point falls within the plotting window,
						 * then it should be included. This is determined
						 * by computing the y-intercepts of the line
						 * connecting the two points in question at
						 * xmin and xmax, and the x-intercepts at the
						 * ymin and ymax. If their y-values are within
						 * the y-range, or their x-values are with the
						 * x-range, it should be
						 * plotted. Otherwise, we should break out of
						 * the current for-loop.
						 */
						 Point prev;
						 double slope;
						 double y_intercept_x_min, y_intercept_x_max;
						 double x_intercept_y_min, x_intercept_y_max;
						 int identical_y_values, identical_x_values;
						 /* Initialize the previous point */
						 prev = to_plot[n_to_plot];
						 
						/* Both x values or both y-values are outside
						 * the clipping rectange on the same side means
						 * we can break since there's no way for their
						 * intercepts to cross the clipping rectangle */
						if (	(xval < x_min && prev.x < x_min)
							||	(xval > x_max && prev.x > x_max)
							||	(yval < y_min && prev.y < y_min)
							||	(yval > y_max && prev.y > y_max)
						)
							break;
						 
						/* For identical x-values within the x-range,
						 * we should set the x-intercepts, and set the
						 * the y-intercepts to failing values
						 */
						if ((int)xval == prev.x) {
							x_intercept_y_min = xval;
							x_intercept_y_max = xval;
							y_intercept_x_min = y_min - 1;
							y_intercept_x_max = y_max + 1;
						}
						/* For identical y-values within the y-range,
						 * we should set the y-intercepts, and set the
						 * x-intercepts to failing values
						 */
						else if ((int)yval == prev.y) {
							x_intercept_y_min = x_min - 1;
							x_intercept_y_max = x_max + 1;
							y_intercept_x_min = yval;
							y_intercept_x_max = yval;
						}
						/* distinct y- and x-values; compute slopes */
						else {
							/* First compute the y-intercepts */
							slope = ((double)(yval - prev.y)) / ((double)(xval - prev.x));
							y_intercept_x_min = prev.y + slope * (x_min - prev.x);
							y_intercept_x_max = prev.y + slope * (x_max - prev.x);
							/* Then compute the x-intercepts */
							x_intercept_y_min = prev.x + (y_min - prev.y) / slope;
							x_intercept_y_max = prev.x + (y_max - prev.y) / slope;
						}
						
						 /* Now check if all the intercepts fall outside
						  * the clipping window */
						 if (	(	y_intercept_x_min < y_min
								||	y_intercept_x_min > y_max)
							&&	(	y_intercept_x_max < y_min
								||	y_intercept_x_max > y_max)
							&&	(	x_intercept_y_min < x_min
								||	x_intercept_y_min > x_max)
							&&	(	x_intercept_y_max < x_min
								||	x_intercept_y_max > x_max)
						)
							break;
					}
				}
				/* Call apricot's polyline function */
				if (n_to_plot > 1)
					apc_gp_draw_poly(widget_handle, n_to_plot, to_plot);
				
				/* Keep track of the starting position */
				i += n_to_plot;
			}
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	HandleBad => 1,
	BadCode => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs and nans gracefully by treating the same
			 * way as I would bad values.
			 */
			for(i = 0; i < n_size; /* no action */) {
				for(n_to_plot = 0; n_to_plot + i < n_size; n_to_plot++) {
					/* Get the values from the array */
					int total_offset = n_to_plot + i;
					xval = $x(n => total_offset);
					yval = $y(n => total_offset);
					
					/* finish this segment if we encounter nan or a bad value */
					if (xval != xval || yval != yval		/* nan check */
						|| $ISBAD(x(n => total_offset))		/* bad value */
						|| $ISBAD(y(n => total_offset))) {	/* checks    */
						/* increment i so that it skips this value on
						 * the next round
						 */
						i++;
						break;
					}
					else {
						/* handle infinities */
						if (xval == xval + 1) {
							if (xval < 0)
								xval = -MY_BIG_NUMBER;
							else
								xval = MY_BIG_NUMBER;
						}
						if (yval == yval + 1) {
							if (yval < 0)
								yval = -MY_BIG_NUMBER;
							else
								yval = MY_BIG_NUMBER;
						}
						/* Handle very large values */
						if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
						if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
						if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
						if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
						
						to_plot[n_to_plot].x = xval;
						to_plot[n_to_plot].y = yval;
					}
				}
				/* Call apricot's polyline function */
				if (n_to_plot > 1)
					apc_gp_draw_poly(widget_handle, n_to_plot, to_plot);
				
				/* Keep track of the starting position */
				i += n_to_plot;
			}
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	Doc => q{

=head2 pdl_polylines

 working here:
  Prima Signature: (widget; x(n); y(n); properties)

=for ref

Draws a multi-segment line on a widget with the given x- and y-coordinates.

This is useful for making line-drawings, such as plotting data.

Applicable properties include colors backColors linePatterns lineWidths
lineJoins lineEnds rops rop2s

=for example

 # Draw a sine curve on the widget:
 my $x = sequence(200);
 my $y = ( sin($x / 20) + 1 ) * 50;
 $canvas->pdl_polylines($x, $y);

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, lineJoins, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.
				color, backColor, linePattern, lineWidth, lineJoin, lineEnd, rop, rop2

=cut

####################
# prima_put_images #
####################

# Not implemented

#############################
# prima_put_images_indirect #
#############################

# Not implemented

#############################
# prima_put_images_indirect #
#############################

# Not implemented

#################
# prima_rects3d #
#################

# Not implemented

###################
# prima_rect_foci #
###################

# Not implemented

####################
# prima_rectangles #
####################

@properties = qw(colors backColors clipRects linePatterns lineWidths rops rop2s translates);
pp_def('prima_rectangles',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMCode => generate_PMCode_for('rectangles', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's rectangle function */
			apc_gp_rectangle(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_bars

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws filled rectangle from corner (x1, y1) to (x2, y2).

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#################
# prima_sectors #
#################

@properties = qw(colors backColors clipRects lineEnds linePatterns lineWidths rops rop2s translates);
pp_def('prima_sectors',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMCode => generate_PMCode_for('sectors', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for sectors, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_sector(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_sectors

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters. The
difference between this command and L<chords> is that this command does
not connect the ends of the arcs with straight lines but leaves the
arcs open

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#################
# prima_splines #
#################

# Not implemented

########################
# prima_stretch_images #
########################

# Not implemented

###################
# prima_texts_out #
###################

# Not implemented

pp_addpm({At=>'Bot'},<<'EOD');

=head1 ERROR MESSAGE

This function may throw the following exception:

=head2 Your widget must be derived from Prima::Drawable

This means that you tried to draw on something that is not a Prima::Drawable
object, or a class derived from it. I don't know enough about the Prima
internals to know if that has any hope of working, but why do it in the first
place?

=head1 TODO

These are all the things I wish to do, or have done:

=over

=item Full Drawabel API

I would like a PDL function for every drawable function in the API.
Prima Drawable functions that currently do not have an equivalent PDL
implementation include L<Prima::Drawable/draw_text>,
L<Prima::Drawable/fill_spline>, L<Prima::Drawable/put_image>,
L<Prima::Drawable/put_image_indirect>, L<Prima::Drawable/rect3d>,
L<Prima::Drawable/rect_focus>, L<Prima::Drawable/spline>,
L<Prima::Drawable/stretch_image>, and L<Prima::Drawable/text_out>

=item PS Functionality

Currently, this library only implements PDL functions using the apricot
library. Since L<Prima::PS::Drawable> implements its own drawing
functions, none of the PDL drawing functions will work with a PS drawable.
They need their own specially created functions that will emit postscript
code. It's not a hard problem, but it will take some time and work, and
it's likely that a seperate interface would be best.

=item Bad Value Support

PLplot's bindings have a very sensible interpretation for bad values:
they are omitted. This should be replicated in this library. It has been
implemented in L</polylines> and L</fillpolys>, but not for the other
functions.

=back

=head1 AUTHOR

David Mertens, E<lt>dcmertens.perl@gmail.comE<gt>.

=head1 SEE ALSO

This is built as an extension for the Prima toolkit, http://www.prima.eu.org/, L<Prima>.

This is built using (and targeted at users of) the Perl Data Language, L<PDL>.

Since this amounts to a plotting package, you should check out other plotting
packages available for PDL. Two notable examples are L<PDL::Graphics::PLplot>
and L<PDL::Graphics::PGPLOT>.

Another interface between PDL and Prima is <PDL::PrimaImage>. I am indebted to
Dmitry for that module because it gave me a working template for this module,
including a working Makefile.PL. Thanks Dmitry!

=cut

EOD

pp_export_nothing();
pp_done();
